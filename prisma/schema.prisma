// Prisma schema for Kesennuma Digital Experiences
// Using SQLite for local development (switch to PostgreSQL for production)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// ============================================
// USER MANAGEMENT
// ============================================

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  name      String?
  avatar    String?
  bio       String?
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  stories Story[]

  @@map("users")
}

// ============================================
// STORY AND CONTENT SYSTEM
// ============================================

model Story {
  id             Int       @id @default(autoincrement())
  title          String
  slug           String    @unique
  excerpt        String?
  latitude       Float
  longitude      Float
  coverImageUrl  String?   @map("cover_image_url")
  authorId       String    @map("author_id")
  status         String    @default("pending_review") // pending_review, approved, rejected, flagged
  featured       Boolean   @default(false)
  viewCount      Int       @default(0) @map("view_count")
  publishedAt    DateTime? @map("published_at")
  createdAt      DateTime  @default(now()) @map("created_at")
  updatedAt      DateTime  @updatedAt @map("updated_at")

  // Relations
  author          User                @relation(fields: [authorId], references: [id], onDelete: Cascade)
  contentBlocks   StoryContent[]
  media           StoryMedia[]
  tags            StoryTag[]
  keyframes       CameraKeyframe[]
  itineraryStops  ItineraryStop[]
  visits          Visit[]
  campaignLocations CampaignLocation[]

  @@index([authorId])
  @@index([status])
  @@index([featured])
  @@index([latitude, longitude])
  @@map("stories")
}

model StoryContent {
  id        String   @id @default(uuid())
  storyId   Int      @map("story_id")
  blockType String   @map("block_type") // text, image, video, gallery, quote, embed, model3d
  order     Int
  data      String   // Flexible JSON for different block types (stored as JSON string in SQLite)
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  story Story @relation(fields: [storyId], references: [id], onDelete: Cascade)

  @@index([storyId, order])
  @@map("story_content")
}

model StoryMedia {
  id           String   @id @default(uuid())
  storyId      Int      @map("story_id")
  mediaType    String   @map("media_type") // image, video, model3d, point_cloud
  url          String
  thumbnailUrl String?  @map("thumbnail_url")
  metadata     String?  // width, height, duration, etc. (stored as JSON string in SQLite)
  fileSize     Int      @map("file_size") // in bytes
  isUsed       Boolean  @default(false) @map("is_used") // Track if referenced in content blocks
  uploadedAt   DateTime @default(now()) @map("uploaded_at")

  // Relations
  story Story @relation(fields: [storyId], references: [id], onDelete: Cascade)

  @@index([storyId])
  @@index([mediaType])
  @@map("story_media")
}

// ============================================
// TAGGING SYSTEM
// ============================================

model Tag {
  id         Int        @id @default(autoincrement())
  name       String     @unique
  slug       String     @unique
  color      String?    // Hex color code
  icon       String?    // Icon name or emoji
  storyCount Int        @default(0) @map("story_count") // Denormalized for performance
  createdAt  DateTime   @default(now()) @map("created_at")

  // Relations
  stories StoryTag[]

  @@map("tags")
}

model StoryTag {
  storyId Int @map("story_id")
  tagId   Int @map("tag_id")

  // Relations
  story Story @relation(fields: [storyId], references: [id], onDelete: Cascade)
  tag   Tag   @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([storyId, tagId])
  @@map("story_tags")
}

// ============================================
// CAMERA KEYFRAMES (3D View Positions)
// ============================================

model CameraKeyframe {
  id          String   @id @default(uuid())
  storyId     Int      @map("story_id")
  latitude    Float
  longitude   Float
  altitude    Float    // Height above terrain in meters
  heading     Float    // Camera rotation (0-360 degrees)
  pitch       Float    // Camera tilt (-90 to 90 degrees)
  roll        Float    @default(0) // Camera roll (usually 0)
  description String?
  isDefault   Boolean  @default(false) @map("is_default") // Default view for this story
  createdAt   DateTime @default(now()) @map("created_at")

  // Relations
  story          Story           @relation(fields: [storyId], references: [id], onDelete: Cascade)
  itineraryStops ItineraryStop[]

  @@index([storyId])
  @@map("camera_keyframes")
}

// ============================================
// ITINERARY SYSTEM
// ============================================

model Itinerary {
  id          String   @id @default(uuid())
  name        String
  slug        String   @unique
  description String?
  featured    Boolean  @default(false)
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  stops ItineraryStop[]

  @@index([featured])
  @@map("itineraries")
}

model ItineraryStop {
  id           String  @id @default(uuid())
  itineraryId  String  @map("itinerary_id")
  storyId      Int     @map("story_id")
  order        Int
  keyframeId   String? @map("keyframe_id") // Optional custom keyframe

  // Relations
  itinerary Itinerary       @relation(fields: [itineraryId], references: [id], onDelete: Cascade)
  story     Story           @relation(fields: [storyId], references: [id], onDelete: Restrict)
  keyframe  CameraKeyframe? @relation(fields: [keyframeId], references: [id], onDelete: SetNull)

  @@unique([itineraryId, order])
  @@index([itineraryId, order])
  @@map("itinerary_stops")
}

// ============================================
// NFT STAMP RALLY SYSTEM
// ============================================

model NFTCampaign {
  id              String    @id @default(uuid())
  name            String
  slug            String    @unique
  description     String?
  requiredVisits  Int       @default(1) @map("required_visits") // Total visits needed across all locations
  contractAddress String?   @map("contract_address") // Base chain contract address
  nftImageUrl     String?   @map("nft_image_url") // NFT artwork URL
  active          Boolean   @default(false)
  startDate       DateTime? @map("start_date")
  endDate         DateTime? @map("end_date")
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  // Relations
  locations CampaignLocation[]
  visits    Visit[]
  nftStamps NFTStamp[]

  @@index([active])
  @@map("nft_campaigns")
}

// Many-to-many relationship between campaigns and story locations
model CampaignLocation {
  campaignId String @map("campaign_id")
  storyId    Int    @map("story_id")
  order      Int?   // Optional order if campaign requires visiting locations in sequence

  // Relations
  campaign NFTCampaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  story    Story       @relation(fields: [storyId], references: [id], onDelete: Cascade)

  @@id([campaignId, storyId])
  @@index([campaignId])
  @@index([storyId])
  @@map("campaign_locations")
}

model Visit {
  id            String   @id @default(uuid())
  locationId    Int      @map("location_id") // References Story.id
  walletAddress String   @map("wallet_address")
  campaignId    String?  @map("campaign_id")
  timestamp     DateTime @default(now())

  // Relations
  location Story        @relation(fields: [locationId], references: [id], onDelete: Cascade)
  campaign NFTCampaign? @relation(fields: [campaignId], references: [id], onDelete: SetNull)

  @@index([walletAddress, campaignId])
  @@index([locationId])
  @@map("visits")
}

model NFTStamp {
  id              String   @id @default(uuid())
  walletAddress   String   @map("wallet_address")
  campaignId      String   @map("campaign_id")
  tokenId         String   @map("token_id") // On-chain token ID
  transactionHash String   @map("transaction_hash")
  mintedAt        DateTime @default(now()) @map("minted_at")

  // Relations
  campaign NFTCampaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)

  @@unique([walletAddress, campaignId]) // One NFT per wallet per campaign
  @@index([walletAddress])
  @@index([campaignId])
  @@map("nft_stamps")
}

// ============================================
// INDEXES AND PERFORMANCE
// ============================================

// Note: Spatial indexes for geospatial queries should be created manually:
// CREATE INDEX idx_stories_location ON stories USING GIST (ll_to_earth(latitude, longitude));
// Requires PostGIS extension enabled in Supabase
